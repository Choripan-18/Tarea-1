{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww30040\viewh16280\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 1. Seg\'fan una discusi\'f3n en Stack Overflow, pod\'e9moste ver que es mas conveniente representar los pixeles con unsigned char*, debido a que este tipo de variables abarca valores\
entre [0,255], el cual coincide con el rango de las im\'e1genes RGB. Adem\'e1s, seg\'fan Microsoft la cantidad de bytes de cada tipo de dato, y podemos apreciar que un dato del tipo <unsigned char> ocupa solamente 1byte (8bits) a diferencia del int por ejemplo, el cual ocupa 4bytes (32bits).\
\
\
\
\pard\tx720\tx1618\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx8640\pardirnatural\partightenfactor0
\cf0 2. Como vimos <unsigned char> ocupa 1byte o 8bits y <unsigned int> ocupa 4byte o 32bits haciendo los c\'e1lculos:\
 - En unsigned char:\
	- Cada pixel tendr\'e1 3 bytes porque como se especifica tiene los 3 canales, cada uno almacenado en 1 byte.\
	- Por lo que quedar\'edamos  NxN pixeles y cada uno con 3 bytes\
	-Entonces, si ocupamos unsigned char estar\'edamos utilizando NxNx3 bytes de memoria.}